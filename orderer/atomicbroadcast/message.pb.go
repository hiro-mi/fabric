// Code generated by protoc-gen-go.
// source: message.proto
// DO NOT EDIT!

package atomicbroadcast

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Header_Type int32

const (
	Header_MESSAGE                   Header_Type = 0
	Header_CONFIGURATION_TRANSACTION Header_Type = 1
	Header_CONFIGURATION_ITEM        Header_Type = 2
)

var Header_Type_name = map[int32]string{
	0: "MESSAGE",
	1: "CONFIGURATION_TRANSACTION",
	2: "CONFIGURATION_ITEM",
}
var Header_Type_value = map[string]int32{
	"MESSAGE":                   0,
	"CONFIGURATION_TRANSACTION": 1,
	"CONFIGURATION_ITEM":        2,
}

func (x Header_Type) String() string {
	return proto.EnumName(Header_Type_name, int32(x))
}
func (Header_Type) EnumDescriptor() ([]byte, []int) { return fileDescriptor1, []int{0, 0} }

// Header is a generic replay prevention and identity message to include in a signed payload
type Header struct {
	// Version indicates message protocol version
	Version int32 `protobuf:"varint,1,opt,name=version" json:"version,omitempty"`
	// Timestamp is the local time when the message was created
	// by the sender
	Timestamp *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp,omitempty"`
	// Type of the transaction
	Type Header_Type `protobuf:"varint,3,opt,name=type,enum=atomicbroadcast.Header_Type" json:"type,omitempty"`
	// Creator of the message, specified as a certificate chain
	Creator []byte `protobuf:"bytes,4,opt,name=creator,proto3" json:"creator,omitempty"`
	// Arbitrary number that may only be used once. Can be used to detect replay attacks.
	Nonce []byte `protobuf:"bytes,5,opt,name=nonce,proto3" json:"nonce,omitempty"`
	// Identifier of the chain this message is bound for
	ChainID []byte `protobuf:"bytes,6,opt,name=chainID,proto3" json:"chainID,omitempty"`
}

func (m *Header) Reset()                    { *m = Header{} }
func (m *Header) String() string            { return proto.CompactTextString(m) }
func (*Header) ProtoMessage()               {}
func (*Header) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *Header) GetTimestamp() *google_protobuf.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

// Payload is the message contents (and header to allow for signing)
type Payload struct {
	// Header is included to provide identity and prevent replay
	Header *Header `protobuf:"bytes,1,opt,name=header" json:"header,omitempty"`
	// Data, the encoding of which is defined by the type in the header
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Payload) Reset()                    { *m = Payload{} }
func (m *Payload) String() string            { return proto.CompactTextString(m) }
func (*Payload) ProtoMessage()               {}
func (*Payload) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *Payload) GetHeader() *Header {
	if m != nil {
		return m.Header
	}
	return nil
}

// Envelope wraps a Payload with a signature so that the message may be authenticated
type Envelope struct {
	// A marshaled Payload
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	// A signature by the creator specified in the Payload header
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *Envelope) Reset()                    { *m = Envelope{} }
func (m *Envelope) String() string            { return proto.CompactTextString(m) }
func (*Envelope) ProtoMessage()               {}
func (*Envelope) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func init() {
	proto.RegisterType((*Header)(nil), "atomicbroadcast.Header")
	proto.RegisterType((*Payload)(nil), "atomicbroadcast.Payload")
	proto.RegisterType((*Envelope)(nil), "atomicbroadcast.Envelope")
	proto.RegisterEnum("atomicbroadcast.Header_Type", Header_Type_name, Header_Type_value)
}

func init() { proto.RegisterFile("message.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 342 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x74, 0x90, 0x41, 0x4f, 0xc2, 0x40,
	0x10, 0x85, 0x2d, 0x96, 0x22, 0x03, 0x2a, 0xd9, 0x18, 0xad, 0x04, 0x63, 0xd3, 0x53, 0x4f, 0xc5,
	0xe0, 0xc5, 0x6b, 0xc5, 0x8a, 0x35, 0xa1, 0x98, 0xa5, 0x9e, 0xcd, 0xd2, 0xae, 0xa5, 0x09, 0xed,
	0x36, 0xdb, 0x85, 0x84, 0xff, 0xe3, 0x0f, 0x35, 0xec, 0x52, 0x89, 0x26, 0xde, 0xf6, 0xcd, 0x7c,
	0xf3, 0x76, 0xe6, 0xc1, 0x69, 0x4e, 0xab, 0x8a, 0xa4, 0xd4, 0x2d, 0x39, 0x13, 0x0c, 0x9d, 0x13,
	0xc1, 0xf2, 0x2c, 0x5e, 0x70, 0x46, 0x92, 0x98, 0x54, 0xa2, 0x7f, 0x9b, 0x32, 0x96, 0xae, 0xe8,
	0x50, 0xb6, 0x17, 0xeb, 0xcf, 0xa1, 0xc8, 0x72, 0x5a, 0x09, 0x92, 0x97, 0x6a, 0xc2, 0xfe, 0x6a,
	0x80, 0xf1, 0x42, 0x49, 0x42, 0x39, 0x32, 0xa1, 0xb5, 0xa1, 0xbc, 0xca, 0x58, 0x61, 0x6a, 0x96,
	0xe6, 0x34, 0x71, 0x2d, 0xd1, 0x03, 0xb4, 0x7f, 0xe6, 0xcc, 0x86, 0xa5, 0x39, 0x9d, 0x51, 0xdf,
	0x55, 0xce, 0x6e, 0xed, 0xec, 0x46, 0x35, 0x81, 0x0f, 0x30, 0xba, 0x03, 0x5d, 0x6c, 0x4b, 0x6a,
	0x1e, 0x5b, 0x9a, 0x73, 0x36, 0x1a, 0xb8, 0x7f, 0xf6, 0x73, 0xd5, 0xd7, 0x6e, 0xb4, 0x2d, 0x29,
	0x96, 0xe4, 0x6e, 0x8b, 0x98, 0x53, 0x22, 0x18, 0x37, 0x75, 0x4b, 0x73, 0xba, 0xb8, 0x96, 0xe8,
	0x02, 0x9a, 0x05, 0x2b, 0x62, 0x6a, 0x36, 0x65, 0x5d, 0x09, 0xc9, 0x2f, 0x49, 0x56, 0x04, 0x4f,
	0xa6, 0xb1, 0xe7, 0x95, 0xb4, 0x5f, 0x41, 0xdf, 0xf9, 0xa2, 0x0e, 0xb4, 0xa6, 0xfe, 0x7c, 0xee,
	0x4d, 0xfc, 0xde, 0x11, 0xba, 0x81, 0xeb, 0xf1, 0x2c, 0x7c, 0x0e, 0x26, 0xef, 0xd8, 0x8b, 0x82,
	0x59, 0xf8, 0x11, 0x61, 0x2f, 0x9c, 0x7b, 0xe3, 0xdd, 0xbb, 0xa7, 0xa1, 0x4b, 0x40, 0xbf, 0xdb,
	0x41, 0xe4, 0x4f, 0x7b, 0x0d, 0x3b, 0x84, 0xd6, 0x1b, 0xd9, 0xae, 0x18, 0x49, 0xd0, 0x10, 0x8c,
	0xa5, 0xdc, 0x5a, 0xa6, 0xd4, 0x19, 0x5d, 0xfd, 0x73, 0x14, 0xde, 0x63, 0x08, 0x81, 0x9e, 0x10,
	0x41, 0x64, 0x70, 0x5d, 0x2c, 0xdf, 0xf6, 0x23, 0x9c, 0xf8, 0xc5, 0x86, 0xae, 0x98, 0xba, 0xb8,
	0x54, 0xde, 0xd2, 0xb1, 0x8b, 0x6b, 0x89, 0x06, 0xd0, 0xae, 0xb2, 0xb4, 0x20, 0x62, 0xcd, 0xe9,
	0x7e, 0xfc, 0x50, 0x58, 0x18, 0x32, 0xfa, 0xfb, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf9, 0x40,
	0x35, 0xf3, 0x04, 0x02, 0x00, 0x00,
}
