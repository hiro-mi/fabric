// Code generated by protoc-gen-go.
// source: ab.proto
// DO NOT EDIT!

/*
Package atomicbroadcast is a generated protocol buffer package.

It is generated from these files:
	ab.proto

It has these top-level messages:
	BroadcastResponse
	BroadcastMessage
	SignaturePolicyEnvelope
	SignaturePolicy
	SeekInfo
	Acknowledgement
	DeliverUpdate
	Block
	DeliverResponse
*/
package atomicbroadcast

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// These status codes are intended to resemble selected HTTP status codes
type Status int32

const (
	Status_SUCCESS             Status = 0
	Status_BAD_REQUEST         Status = 400
	Status_FORBIDDEN           Status = 403
	Status_NOT_FOUND           Status = 404
	Status_SERVICE_UNAVAILABLE Status = 503
)

var Status_name = map[int32]string{
	0:   "SUCCESS",
	400: "BAD_REQUEST",
	403: "FORBIDDEN",
	404: "NOT_FOUND",
	503: "SERVICE_UNAVAILABLE",
}
var Status_value = map[string]int32{
	"SUCCESS":             0,
	"BAD_REQUEST":         400,
	"FORBIDDEN":           403,
	"NOT_FOUND":           404,
	"SERVICE_UNAVAILABLE": 503,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}
func (Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Start may be specified to a specific block number, or may be request from the newest or oldest available
// The start location is always inclusive, so the first reply from NEWEST will contain the newest block at the time
// of reception, it will must not wait until a new block is created.  Similarly, when SPECIFIED, and SpecifiedNumber = 10
// The first block received must be block 10, not block 11
type SeekInfo_StartType int32

const (
	SeekInfo_NEWEST    SeekInfo_StartType = 0
	SeekInfo_OLDEST    SeekInfo_StartType = 1
	SeekInfo_SPECIFIED SeekInfo_StartType = 2
)

var SeekInfo_StartType_name = map[int32]string{
	0: "NEWEST",
	1: "OLDEST",
	2: "SPECIFIED",
}
var SeekInfo_StartType_value = map[string]int32{
	"NEWEST":    0,
	"OLDEST":    1,
	"SPECIFIED": 2,
}

func (x SeekInfo_StartType) String() string {
	return proto.EnumName(SeekInfo_StartType_name, int32(x))
}
func (SeekInfo_StartType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4, 0} }

type BroadcastResponse struct {
	Status Status `protobuf:"varint,1,opt,name=Status,json=status,enum=atomicbroadcast.Status" json:"Status,omitempty"`
}

func (m *BroadcastResponse) Reset()                    { *m = BroadcastResponse{} }
func (m *BroadcastResponse) String() string            { return proto.CompactTextString(m) }
func (*BroadcastResponse) ProtoMessage()               {}
func (*BroadcastResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type BroadcastMessage struct {
	Data []byte `protobuf:"bytes,1,opt,name=Data,json=data,proto3" json:"Data,omitempty"`
}

func (m *BroadcastMessage) Reset()                    { *m = BroadcastMessage{} }
func (m *BroadcastMessage) String() string            { return proto.CompactTextString(m) }
func (*BroadcastMessage) ProtoMessage()               {}
func (*BroadcastMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// SignaturePolicyEnvelope wraps a SignaturePolicy and includes a version for future enhancements
type SignaturePolicyEnvelope struct {
	Version    int32            `protobuf:"varint,1,opt,name=Version,json=version" json:"Version,omitempty"`
	Policy     *SignaturePolicy `protobuf:"bytes,2,opt,name=Policy,json=policy" json:"Policy,omitempty"`
	Identities [][]byte         `protobuf:"bytes,3,rep,name=Identities,json=identities,proto3" json:"Identities,omitempty"`
}

func (m *SignaturePolicyEnvelope) Reset()                    { *m = SignaturePolicyEnvelope{} }
func (m *SignaturePolicyEnvelope) String() string            { return proto.CompactTextString(m) }
func (*SignaturePolicyEnvelope) ProtoMessage()               {}
func (*SignaturePolicyEnvelope) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *SignaturePolicyEnvelope) GetPolicy() *SignaturePolicy {
	if m != nil {
		return m.Policy
	}
	return nil
}

// SignaturePolicy is a recursive message structure which defines a featherweight DSL for describing
// policies which are more complicated than 'exactly this signature'.  The NOutOf operator is sufficent
// to express AND as well as OR, as well as of course N out of the following M policies
// SignedBy implies that the signature is from a valid certificate which is signed by the trusted
// authority specified in the bytes.  This will be the certificate itself for a self-signed certificate
// and will be the CA for more traditional certificates
type SignaturePolicy struct {
	// Types that are valid to be assigned to Type:
	//	*SignaturePolicy_SignedBy
	//	*SignaturePolicy_From
	Type isSignaturePolicy_Type `protobuf_oneof:"Type"`
}

func (m *SignaturePolicy) Reset()                    { *m = SignaturePolicy{} }
func (m *SignaturePolicy) String() string            { return proto.CompactTextString(m) }
func (*SignaturePolicy) ProtoMessage()               {}
func (*SignaturePolicy) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isSignaturePolicy_Type interface {
	isSignaturePolicy_Type()
}

type SignaturePolicy_SignedBy struct {
	SignedBy int32 `protobuf:"varint,1,opt,name=SignedBy,json=signedBy,oneof"`
}
type SignaturePolicy_From struct {
	From *SignaturePolicy_NOutOf `protobuf:"bytes,2,opt,name=From,json=from,oneof"`
}

func (*SignaturePolicy_SignedBy) isSignaturePolicy_Type() {}
func (*SignaturePolicy_From) isSignaturePolicy_Type()     {}

func (m *SignaturePolicy) GetType() isSignaturePolicy_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *SignaturePolicy) GetSignedBy() int32 {
	if x, ok := m.GetType().(*SignaturePolicy_SignedBy); ok {
		return x.SignedBy
	}
	return 0
}

func (m *SignaturePolicy) GetFrom() *SignaturePolicy_NOutOf {
	if x, ok := m.GetType().(*SignaturePolicy_From); ok {
		return x.From
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*SignaturePolicy) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _SignaturePolicy_OneofMarshaler, _SignaturePolicy_OneofUnmarshaler, _SignaturePolicy_OneofSizer, []interface{}{
		(*SignaturePolicy_SignedBy)(nil),
		(*SignaturePolicy_From)(nil),
	}
}

func _SignaturePolicy_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*SignaturePolicy)
	// Type
	switch x := m.Type.(type) {
	case *SignaturePolicy_SignedBy:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.SignedBy))
	case *SignaturePolicy_From:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.From); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("SignaturePolicy.Type has unexpected type %T", x)
	}
	return nil
}

func _SignaturePolicy_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*SignaturePolicy)
	switch tag {
	case 1: // Type.SignedBy
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &SignaturePolicy_SignedBy{int32(x)}
		return true, err
	case 2: // Type.From
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SignaturePolicy_NOutOf)
		err := b.DecodeMessage(msg)
		m.Type = &SignaturePolicy_From{msg}
		return true, err
	default:
		return false, nil
	}
}

func _SignaturePolicy_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*SignaturePolicy)
	// Type
	switch x := m.Type.(type) {
	case *SignaturePolicy_SignedBy:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.SignedBy))
	case *SignaturePolicy_From:
		s := proto.Size(x.From)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type SignaturePolicy_NOutOf struct {
	N        int32              `protobuf:"varint,1,opt,name=N,json=n" json:"N,omitempty"`
	Policies []*SignaturePolicy `protobuf:"bytes,2,rep,name=Policies,json=policies" json:"Policies,omitempty"`
}

func (m *SignaturePolicy_NOutOf) Reset()                    { *m = SignaturePolicy_NOutOf{} }
func (m *SignaturePolicy_NOutOf) String() string            { return proto.CompactTextString(m) }
func (*SignaturePolicy_NOutOf) ProtoMessage()               {}
func (*SignaturePolicy_NOutOf) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3, 0} }

func (m *SignaturePolicy_NOutOf) GetPolicies() []*SignaturePolicy {
	if m != nil {
		return m.Policies
	}
	return nil
}

type SeekInfo struct {
	Start           SeekInfo_StartType `protobuf:"varint,1,opt,name=Start,json=start,enum=atomicbroadcast.SeekInfo_StartType" json:"Start,omitempty"`
	SpecifiedNumber uint64             `protobuf:"varint,2,opt,name=SpecifiedNumber,json=specifiedNumber" json:"SpecifiedNumber,omitempty"`
	WindowSize      uint64             `protobuf:"varint,3,opt,name=WindowSize,json=windowSize" json:"WindowSize,omitempty"`
}

func (m *SeekInfo) Reset()                    { *m = SeekInfo{} }
func (m *SeekInfo) String() string            { return proto.CompactTextString(m) }
func (*SeekInfo) ProtoMessage()               {}
func (*SeekInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type Acknowledgement struct {
	Number uint64 `protobuf:"varint,1,opt,name=Number,json=number" json:"Number,omitempty"`
}

func (m *Acknowledgement) Reset()                    { *m = Acknowledgement{} }
func (m *Acknowledgement) String() string            { return proto.CompactTextString(m) }
func (*Acknowledgement) ProtoMessage()               {}
func (*Acknowledgement) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// The update message either causes a seek to a new stream start with a new window, or acknowledges a received block and advances the base of the window
type DeliverUpdate struct {
	// Types that are valid to be assigned to Type:
	//	*DeliverUpdate_Acknowledgement
	//	*DeliverUpdate_Seek
	Type isDeliverUpdate_Type `protobuf_oneof:"Type"`
}

func (m *DeliverUpdate) Reset()                    { *m = DeliverUpdate{} }
func (m *DeliverUpdate) String() string            { return proto.CompactTextString(m) }
func (*DeliverUpdate) ProtoMessage()               {}
func (*DeliverUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isDeliverUpdate_Type interface {
	isDeliverUpdate_Type()
}

type DeliverUpdate_Acknowledgement struct {
	Acknowledgement *Acknowledgement `protobuf:"bytes,1,opt,name=Acknowledgement,json=acknowledgement,oneof"`
}
type DeliverUpdate_Seek struct {
	Seek *SeekInfo `protobuf:"bytes,2,opt,name=Seek,json=seek,oneof"`
}

func (*DeliverUpdate_Acknowledgement) isDeliverUpdate_Type() {}
func (*DeliverUpdate_Seek) isDeliverUpdate_Type()            {}

func (m *DeliverUpdate) GetType() isDeliverUpdate_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *DeliverUpdate) GetAcknowledgement() *Acknowledgement {
	if x, ok := m.GetType().(*DeliverUpdate_Acknowledgement); ok {
		return x.Acknowledgement
	}
	return nil
}

func (m *DeliverUpdate) GetSeek() *SeekInfo {
	if x, ok := m.GetType().(*DeliverUpdate_Seek); ok {
		return x.Seek
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DeliverUpdate) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DeliverUpdate_OneofMarshaler, _DeliverUpdate_OneofUnmarshaler, _DeliverUpdate_OneofSizer, []interface{}{
		(*DeliverUpdate_Acknowledgement)(nil),
		(*DeliverUpdate_Seek)(nil),
	}
}

func _DeliverUpdate_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DeliverUpdate)
	// Type
	switch x := m.Type.(type) {
	case *DeliverUpdate_Acknowledgement:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Acknowledgement); err != nil {
			return err
		}
	case *DeliverUpdate_Seek:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Seek); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DeliverUpdate.Type has unexpected type %T", x)
	}
	return nil
}

func _DeliverUpdate_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DeliverUpdate)
	switch tag {
	case 1: // Type.Acknowledgement
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Acknowledgement)
		err := b.DecodeMessage(msg)
		m.Type = &DeliverUpdate_Acknowledgement{msg}
		return true, err
	case 2: // Type.Seek
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SeekInfo)
		err := b.DecodeMessage(msg)
		m.Type = &DeliverUpdate_Seek{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DeliverUpdate_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DeliverUpdate)
	// Type
	switch x := m.Type.(type) {
	case *DeliverUpdate_Acknowledgement:
		s := proto.Size(x.Acknowledgement)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DeliverUpdate_Seek:
		s := proto.Size(x.Seek)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// This is a temporary data structure, meant to hold the place of the finalized block structure
// This must be a 'block' structure and not a 'batch' structure, although the terminology is slightly confusing
// The requirement is to allow for a consumer of the orderer to declare the unvalidated blockchain as the definitive
// blockchain, without breaking the hash chain or existing proof
type Block struct {
	Number   uint64              `protobuf:"varint,2,opt,name=Number,json=number" json:"Number,omitempty"`
	PrevHash []byte              `protobuf:"bytes,3,opt,name=PrevHash,json=prevHash,proto3" json:"PrevHash,omitempty"`
	Proof    []byte              `protobuf:"bytes,4,opt,name=Proof,json=proof,proto3" json:"Proof,omitempty"`
	Messages []*BroadcastMessage `protobuf:"bytes,5,rep,name=Messages,json=messages" json:"Messages,omitempty"`
}

func (m *Block) Reset()                    { *m = Block{} }
func (m *Block) String() string            { return proto.CompactTextString(m) }
func (*Block) ProtoMessage()               {}
func (*Block) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Block) GetMessages() []*BroadcastMessage {
	if m != nil {
		return m.Messages
	}
	return nil
}

type DeliverResponse struct {
	// Types that are valid to be assigned to Type:
	//	*DeliverResponse_Error
	//	*DeliverResponse_Block
	Type isDeliverResponse_Type `protobuf_oneof:"Type"`
}

func (m *DeliverResponse) Reset()                    { *m = DeliverResponse{} }
func (m *DeliverResponse) String() string            { return proto.CompactTextString(m) }
func (*DeliverResponse) ProtoMessage()               {}
func (*DeliverResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type isDeliverResponse_Type interface {
	isDeliverResponse_Type()
}

type DeliverResponse_Error struct {
	Error Status `protobuf:"varint,1,opt,name=Error,json=error,enum=atomicbroadcast.Status,oneof"`
}
type DeliverResponse_Block struct {
	Block *Block `protobuf:"bytes,2,opt,name=Block,json=block,oneof"`
}

func (*DeliverResponse_Error) isDeliverResponse_Type() {}
func (*DeliverResponse_Block) isDeliverResponse_Type() {}

func (m *DeliverResponse) GetType() isDeliverResponse_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *DeliverResponse) GetError() Status {
	if x, ok := m.GetType().(*DeliverResponse_Error); ok {
		return x.Error
	}
	return Status_SUCCESS
}

func (m *DeliverResponse) GetBlock() *Block {
	if x, ok := m.GetType().(*DeliverResponse_Block); ok {
		return x.Block
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DeliverResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DeliverResponse_OneofMarshaler, _DeliverResponse_OneofUnmarshaler, _DeliverResponse_OneofSizer, []interface{}{
		(*DeliverResponse_Error)(nil),
		(*DeliverResponse_Block)(nil),
	}
}

func _DeliverResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DeliverResponse)
	// Type
	switch x := m.Type.(type) {
	case *DeliverResponse_Error:
		b.EncodeVarint(1<<3 | proto.WireVarint)
		b.EncodeVarint(uint64(x.Error))
	case *DeliverResponse_Block:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Block); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DeliverResponse.Type has unexpected type %T", x)
	}
	return nil
}

func _DeliverResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DeliverResponse)
	switch tag {
	case 1: // Type.Error
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Type = &DeliverResponse_Error{Status(x)}
		return true, err
	case 2: // Type.Block
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Block)
		err := b.DecodeMessage(msg)
		m.Type = &DeliverResponse_Block{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DeliverResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DeliverResponse)
	// Type
	switch x := m.Type.(type) {
	case *DeliverResponse_Error:
		n += proto.SizeVarint(1<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Error))
	case *DeliverResponse_Block:
		s := proto.Size(x.Block)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

func init() {
	proto.RegisterType((*BroadcastResponse)(nil), "atomicbroadcast.BroadcastResponse")
	proto.RegisterType((*BroadcastMessage)(nil), "atomicbroadcast.BroadcastMessage")
	proto.RegisterType((*SignaturePolicyEnvelope)(nil), "atomicbroadcast.SignaturePolicyEnvelope")
	proto.RegisterType((*SignaturePolicy)(nil), "atomicbroadcast.SignaturePolicy")
	proto.RegisterType((*SignaturePolicy_NOutOf)(nil), "atomicbroadcast.SignaturePolicy.NOutOf")
	proto.RegisterType((*SeekInfo)(nil), "atomicbroadcast.SeekInfo")
	proto.RegisterType((*Acknowledgement)(nil), "atomicbroadcast.Acknowledgement")
	proto.RegisterType((*DeliverUpdate)(nil), "atomicbroadcast.DeliverUpdate")
	proto.RegisterType((*Block)(nil), "atomicbroadcast.Block")
	proto.RegisterType((*DeliverResponse)(nil), "atomicbroadcast.DeliverResponse")
	proto.RegisterEnum("atomicbroadcast.Status", Status_name, Status_value)
	proto.RegisterEnum("atomicbroadcast.SeekInfo_StartType", SeekInfo_StartType_name, SeekInfo_StartType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion3

// Client API for AtomicBroadcast service

type AtomicBroadcastClient interface {
	// broadcast receives a reply of Acknowledgement for each BroadcastMessage in order, indicating success or type of failure
	Broadcast(ctx context.Context, opts ...grpc.CallOption) (AtomicBroadcast_BroadcastClient, error)
	// deliver first requires an update containing a seek message, then a stream of block replies is received.
	// The receiver may choose to send an Acknowledgement for any block number it receives, however Acknowledgements must never be more than WindowSize apart
	// To avoid latency, clients will likely acknowledge before the WindowSize has been exhausted, preventing the server from stopping and waiting for an Acknowledgement
	Deliver(ctx context.Context, opts ...grpc.CallOption) (AtomicBroadcast_DeliverClient, error)
}

type atomicBroadcastClient struct {
	cc *grpc.ClientConn
}

func NewAtomicBroadcastClient(cc *grpc.ClientConn) AtomicBroadcastClient {
	return &atomicBroadcastClient{cc}
}

func (c *atomicBroadcastClient) Broadcast(ctx context.Context, opts ...grpc.CallOption) (AtomicBroadcast_BroadcastClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AtomicBroadcast_serviceDesc.Streams[0], c.cc, "/atomicbroadcast.AtomicBroadcast/Broadcast", opts...)
	if err != nil {
		return nil, err
	}
	x := &atomicBroadcastBroadcastClient{stream}
	return x, nil
}

type AtomicBroadcast_BroadcastClient interface {
	Send(*BroadcastMessage) error
	Recv() (*BroadcastResponse, error)
	grpc.ClientStream
}

type atomicBroadcastBroadcastClient struct {
	grpc.ClientStream
}

func (x *atomicBroadcastBroadcastClient) Send(m *BroadcastMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *atomicBroadcastBroadcastClient) Recv() (*BroadcastResponse, error) {
	m := new(BroadcastResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *atomicBroadcastClient) Deliver(ctx context.Context, opts ...grpc.CallOption) (AtomicBroadcast_DeliverClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AtomicBroadcast_serviceDesc.Streams[1], c.cc, "/atomicbroadcast.AtomicBroadcast/Deliver", opts...)
	if err != nil {
		return nil, err
	}
	x := &atomicBroadcastDeliverClient{stream}
	return x, nil
}

type AtomicBroadcast_DeliverClient interface {
	Send(*DeliverUpdate) error
	Recv() (*DeliverResponse, error)
	grpc.ClientStream
}

type atomicBroadcastDeliverClient struct {
	grpc.ClientStream
}

func (x *atomicBroadcastDeliverClient) Send(m *DeliverUpdate) error {
	return x.ClientStream.SendMsg(m)
}

func (x *atomicBroadcastDeliverClient) Recv() (*DeliverResponse, error) {
	m := new(DeliverResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AtomicBroadcast service

type AtomicBroadcastServer interface {
	// broadcast receives a reply of Acknowledgement for each BroadcastMessage in order, indicating success or type of failure
	Broadcast(AtomicBroadcast_BroadcastServer) error
	// deliver first requires an update containing a seek message, then a stream of block replies is received.
	// The receiver may choose to send an Acknowledgement for any block number it receives, however Acknowledgements must never be more than WindowSize apart
	// To avoid latency, clients will likely acknowledge before the WindowSize has been exhausted, preventing the server from stopping and waiting for an Acknowledgement
	Deliver(AtomicBroadcast_DeliverServer) error
}

func RegisterAtomicBroadcastServer(s *grpc.Server, srv AtomicBroadcastServer) {
	s.RegisterService(&_AtomicBroadcast_serviceDesc, srv)
}

func _AtomicBroadcast_Broadcast_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AtomicBroadcastServer).Broadcast(&atomicBroadcastBroadcastServer{stream})
}

type AtomicBroadcast_BroadcastServer interface {
	Send(*BroadcastResponse) error
	Recv() (*BroadcastMessage, error)
	grpc.ServerStream
}

type atomicBroadcastBroadcastServer struct {
	grpc.ServerStream
}

func (x *atomicBroadcastBroadcastServer) Send(m *BroadcastResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *atomicBroadcastBroadcastServer) Recv() (*BroadcastMessage, error) {
	m := new(BroadcastMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _AtomicBroadcast_Deliver_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AtomicBroadcastServer).Deliver(&atomicBroadcastDeliverServer{stream})
}

type AtomicBroadcast_DeliverServer interface {
	Send(*DeliverResponse) error
	Recv() (*DeliverUpdate, error)
	grpc.ServerStream
}

type atomicBroadcastDeliverServer struct {
	grpc.ServerStream
}

func (x *atomicBroadcastDeliverServer) Send(m *DeliverResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *atomicBroadcastDeliverServer) Recv() (*DeliverUpdate, error) {
	m := new(DeliverUpdate)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _AtomicBroadcast_serviceDesc = grpc.ServiceDesc{
	ServiceName: "atomicbroadcast.AtomicBroadcast",
	HandlerType: (*AtomicBroadcastServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Broadcast",
			Handler:       _AtomicBroadcast_Broadcast_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Deliver",
			Handler:       _AtomicBroadcast_Deliver_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: fileDescriptor0,
}

func init() { proto.RegisterFile("ab.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 720 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x8c, 0x54, 0xcd, 0x6e, 0xd3, 0x40,
	0x10, 0xae, 0x13, 0xdb, 0x49, 0xa7, 0x3f, 0x09, 0x0b, 0x6a, 0x43, 0x84, 0xaa, 0x60, 0x24, 0x28,
	0x1c, 0x52, 0x14, 0x2e, 0x20, 0xc1, 0x21, 0x89, 0x1d, 0xd5, 0x52, 0x70, 0x5a, 0x3b, 0x69, 0xb9,
	0x55, 0x4e, 0xbc, 0x29, 0x56, 0x13, 0xaf, 0xe5, 0x75, 0x5b, 0xb5, 0xef, 0x80, 0x54, 0x09, 0xc4,
	0xe3, 0x70, 0xe1, 0xca, 0xfb, 0x70, 0x65, 0x77, 0xb3, 0x09, 0x4d, 0x42, 0x55, 0x4e, 0x9e, 0x99,
	0x9d, 0x6f, 0xfc, 0xcd, 0x37, 0xb3, 0x0b, 0x79, 0xbf, 0x5f, 0x8d, 0x13, 0x92, 0x12, 0x54, 0xf0,
	0x53, 0x32, 0x0e, 0x07, 0xfd, 0x84, 0xf8, 0xc1, 0xc0, 0xa7, 0xa9, 0x61, 0xc2, 0x83, 0xc6, 0xd4,
	0x71, 0x31, 0x8d, 0x49, 0x44, 0x31, 0xda, 0x03, 0xdd, 0x4b, 0xfd, 0xf4, 0x9c, 0x96, 0x94, 0x8a,
	0xb2, 0xbb, 0x59, 0xdb, 0xae, 0x2e, 0xc0, 0xaa, 0x93, 0x63, 0x57, 0xa7, 0xe2, 0x6b, 0x3c, 0x87,
	0xe2, 0xac, 0xca, 0x47, 0x4c, 0xa9, 0x7f, 0x8a, 0x11, 0x02, 0xd5, 0xf4, 0x53, 0x5f, 0x94, 0x58,
	0x77, 0xd5, 0x80, 0xd9, 0xc6, 0x17, 0x05, 0xb6, 0xbd, 0xf0, 0x34, 0x62, 0xa0, 0x04, 0x1f, 0x90,
	0x51, 0x38, 0xb8, 0xb2, 0xa2, 0x0b, 0x3c, 0x22, 0x31, 0x46, 0x25, 0xc8, 0x1d, 0xe1, 0x84, 0x86,
	0x24, 0x12, 0x10, 0xcd, 0xcd, 0x5d, 0x4c, 0x5c, 0xf4, 0x16, 0xf4, 0x49, 0x6e, 0x29, 0xc3, 0x0e,
	0xd6, 0x6a, 0x95, 0x65, 0x3a, 0xf3, 0x35, 0x5d, 0x3d, 0x16, 0x5f, 0xb4, 0x03, 0x60, 0x07, 0x38,
	0x4a, 0xc3, 0x34, 0xc4, 0xb4, 0x94, 0xad, 0x64, 0x19, 0x13, 0x08, 0x67, 0x11, 0xe3, 0x97, 0x02,
	0x85, 0x05, 0x2c, 0x7a, 0x02, 0x79, 0x1e, 0xc2, 0x41, 0xe3, 0x6a, 0x42, 0x64, 0x7f, 0xc5, 0xcd,
	0x53, 0x19, 0x41, 0x1f, 0x40, 0x6d, 0x25, 0x64, 0x2c, 0x99, 0xbc, 0xb8, 0x8f, 0x49, 0xd5, 0xe9,
	0x9c, 0xa7, 0x9d, 0x21, 0x2b, 0xa1, 0x0e, 0x19, 0xac, 0xdc, 0x05, 0x7d, 0x12, 0x41, 0xeb, 0xa0,
	0x38, 0xb2, 0x51, 0x25, 0x42, 0xef, 0x21, 0x2f, 0x00, 0x9c, 0x66, 0x86, 0xd1, 0xfc, 0x9f, 0x26,
	0xf3, 0xb1, 0x44, 0x34, 0x74, 0x50, 0xbb, 0x57, 0x31, 0x36, 0x7e, 0x2a, 0x8c, 0x3b, 0xc6, 0x67,
	0x76, 0x34, 0x24, 0xe8, 0x1d, 0x68, 0x6c, 0x4a, 0x49, 0x2a, 0x67, 0xf8, 0x6c, 0xb9, 0x9e, 0xcc,
	0xac, 0x8a, 0x34, 0x5e, 0xc0, 0xd5, 0x28, 0x37, 0xd1, 0x2e, 0x53, 0x25, 0xc6, 0x83, 0x70, 0x18,
	0xe2, 0xc0, 0x39, 0x1f, 0xf7, 0x71, 0x22, 0xfa, 0x55, 0xdd, 0x02, 0x9d, 0x0f, 0x73, 0x81, 0x8f,
	0xc3, 0x28, 0x20, 0x97, 0x5e, 0x78, 0x8d, 0x99, 0xc0, 0x3c, 0x09, 0x2e, 0x67, 0x11, 0xa3, 0x06,
	0xab, 0xb3, 0xea, 0x08, 0x58, 0xf3, 0xd6, 0xb1, 0xe5, 0x75, 0x8b, 0x2b, 0xdc, 0xee, 0xb4, 0x4d,
	0x6e, 0x2b, 0x68, 0x83, 0x25, 0x1d, 0x58, 0x4d, 0xbb, 0x65, 0x5b, 0x66, 0x31, 0x63, 0xbc, 0x84,
	0x42, 0x7d, 0x70, 0x16, 0x91, 0xcb, 0x11, 0x0e, 0x4e, 0xf1, 0x98, 0x0d, 0x0b, 0x6d, 0x31, 0xe4,
	0x84, 0x87, 0x22, 0x7e, 0xa1, 0x47, 0xc2, 0x33, 0xbe, 0x2b, 0xb0, 0x61, 0xe2, 0x51, 0xc8, 0x36,
	0xa5, 0x17, 0xb3, 0x0d, 0xc3, 0xa8, 0xbd, 0x04, 0x16, 0x90, 0x7f, 0xe9, 0xb9, 0x90, 0xc7, 0x66,
	0x54, 0xf0, 0x17, 0xfe, 0xbb, 0x07, 0x2a, 0x57, 0x49, 0x4e, 0xfb, 0xf1, 0x9d, 0x12, 0xf2, 0xf9,
	0x52, 0x66, 0xcf, 0x26, 0x71, 0xa3, 0x80, 0xd6, 0x18, 0x91, 0xc1, 0xd9, 0x2d, 0xea, 0x99, 0xdb,
	0xd4, 0x51, 0x99, 0x4d, 0x3c, 0xc1, 0x17, 0xfb, 0x3e, 0xfd, 0x2c, 0x74, 0x5b, 0x67, 0xf3, 0x94,
	0x3e, 0x7a, 0x04, 0xda, 0x41, 0x42, 0xc8, 0xb0, 0xa4, 0x8a, 0x03, 0x2d, 0xe6, 0x0e, 0x5b, 0xbd,
	0xbc, 0xbc, 0x5b, 0xb4, 0xa4, 0x89, 0x1d, 0x79, 0xba, 0x44, 0x68, 0xf1, 0x16, 0xba, 0xf9, 0xb1,
	0x84, 0x18, 0xd7, 0x50, 0x90, 0x52, 0xdd, 0xba, 0xe7, 0x9a, 0x95, 0x24, 0x24, 0xb9, 0xe7, 0x9a,
	0xb3, 0xee, 0x34, 0xcc, 0xf3, 0x50, 0x55, 0x76, 0x25, 0x05, 0xd9, 0x5a, 0xfe, 0x3f, 0x3f, 0xe5,
	0xf9, 0x7d, 0x6e, 0x4c, 0xe5, 0x78, 0xe5, 0x4f, 0x1f, 0x14, 0xb4, 0x06, 0x39, 0xaf, 0xd7, 0x6c,
	0x5a, 0x9e, 0xc7, 0x96, 0xa0, 0x08, 0x6b, 0x8d, 0xba, 0x79, 0xe2, 0x5a, 0x87, 0x3d, 0xbe, 0x09,
	0x37, 0x59, 0xb4, 0x09, 0xab, 0xad, 0x8e, 0xdb, 0xb0, 0x4d, 0xd3, 0x72, 0x8a, 0x5f, 0x85, 0xef,
	0x74, 0xba, 0x27, 0xad, 0x4e, 0xcf, 0x31, 0x8b, 0xdf, 0xb2, 0xec, 0x91, 0x78, 0xe8, 0x59, 0xee,
	0x91, 0xdd, 0xb4, 0x4e, 0x7a, 0x4e, 0xfd, 0xa8, 0x6e, 0xb7, 0xeb, 0x8d, 0xb6, 0x55, 0xfc, 0x9d,
	0xad, 0xfd, 0x60, 0x57, 0xb9, 0x2e, 0xd8, 0xcc, 0x34, 0x40, 0x9f, 0x60, 0xf5, 0xaf, 0x73, 0xbf,
	0x58, 0x65, 0xe3, 0xee, 0x94, 0xa9, 0x66, 0xc6, 0xca, 0xae, 0xf2, 0x5a, 0x41, 0x87, 0x90, 0x93,
	0x62, 0xa2, 0x9d, 0x25, 0xd0, 0xdc, 0x46, 0x96, 0x2b, 0x77, 0x9d, 0xcf, 0x97, 0xec, 0xeb, 0xe2,
	0x85, 0x7e, 0xf3, 0x27, 0x00, 0x00, 0xff, 0xff, 0xdd, 0xa9, 0x3a, 0x84, 0xad, 0x05, 0x00, 0x00,
}
