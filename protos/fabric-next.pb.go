// Code generated by protoc-gen-go.
// source: fabric-next.proto
// DO NOT EDIT!

package protos

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "google/protobuf"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type Message2_Type int32

const (
	// Undefined exists to prevent invalid message construction.
	Message2_UNDEFINED Message2_Type = 0
	// Handshake messages.
	Message2_DISCOVERY Message2_Type = 1
	// Sent to catch up with existing peers.
	Message2_SYNC Message2_Type = 2
	// Sent from SDK to endorser. Payload is a Proposal.
	Message2_PROPOSAL Message2_Type = 3
	// Reserved for future use.
	Message2_PROPOSAL_SET Message2_Type = 4
	// Sent from endorser to SDK. Payload is a ProposalResponse.
	Message2_PROPOSAL_RESULT Message2_Type = 5
	// Reserved for future use.
	Message2_PROPOSAL_SET_RESULT Message2_Type = 6
	// Sent from SDK to peer for relay or ordering service. Payload is a
	// Transaction2.
	Message2_TRANSACTION Message2_Type = 7
)

var Message2_Type_name = map[int32]string{
	0: "UNDEFINED",
	1: "DISCOVERY",
	2: "SYNC",
	3: "PROPOSAL",
	4: "PROPOSAL_SET",
	5: "PROPOSAL_RESULT",
	6: "PROPOSAL_SET_RESULT",
	7: "TRANSACTION",
}
var Message2_Type_value = map[string]int32{
	"UNDEFINED":           0,
	"DISCOVERY":           1,
	"SYNC":                2,
	"PROPOSAL":            3,
	"PROPOSAL_SET":        4,
	"PROPOSAL_RESULT":     5,
	"PROPOSAL_SET_RESULT": 6,
	"TRANSACTION":         7,
}

func (x Message2_Type) String() string {
	return proto.EnumName(Message2_Type_name, int32(x))
}

type Proposal_Type int32

const (
	// Undefined exists to prevent invalid message construction.
	Proposal_UNDEFINED Proposal_Type = 0
	// A chaincode. The payload is a ChaincodeSpec.
	Proposal_CHAINCODE Proposal_Type = 1
)

var Proposal_Type_name = map[int32]string{
	0: "UNDEFINED",
	1: "CHAINCODE",
}
var Proposal_Type_value = map[string]int32{
	"UNDEFINED": 0,
	"CHAINCODE": 1,
}

func (x Proposal_Type) String() string {
	return proto.EnumName(Proposal_Type_name, int32(x))
}

// Envelope is used to deliver a message
type Envelope struct {
	// Signature of the message.
	Signature []byte `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
	// The message.
	Message *Message2 `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
}

func (m *Envelope) Reset()         { *m = Envelope{} }
func (m *Envelope) String() string { return proto.CompactTextString(m) }
func (*Envelope) ProtoMessage()    {}

func (m *Envelope) GetMessage() *Message2 {
	if m != nil {
		return m.Message
	}
	return nil
}

// A Message2 encapsulates a payload of the indicated type in this message.
type Message2 struct {
	// Type of this message.
	Type Message2_Type `protobuf:"varint,1,opt,name=type,enum=protos.Message2_Type" json:"type,omitempty"`
	// Version indicates message protocol version.
	Version int32 `protobuf:"varint,2,opt,name=version" json:"version,omitempty"`
	// Timestamp is the time that the message was created as defined by the
	// sender.
	Timestamp *google_protobuf.Timestamp `protobuf:"bytes,3,opt,name=timestamp" json:"timestamp,omitempty"`
	// The payload in this message.
	Payload []byte `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *Message2) Reset()         { *m = Message2{} }
func (m *Message2) String() string { return proto.CompactTextString(m) }
func (*Message2) ProtoMessage()    {}

func (m *Message2) GetTimestamp() *google_protobuf.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

// A Proposal is sent to an endorser for endorsement. The proposal contains
// a payload (such as a ChaincodeSpec) based on the type field.
type Proposal struct {
	// Type of this message.
	Type Proposal_Type `protobuf:"varint,1,opt,name=type,enum=protos.Proposal_Type" json:"type,omitempty"`
	// Unique ID corresponding to this proposal
	Id string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	// The payload of the proposal as defined by the proposal type.
	Payload []byte `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *Proposal) Reset()         { *m = Proposal{} }
func (m *Proposal) String() string { return proto.CompactTextString(m) }
func (*Proposal) ProtoMessage()    {}

// A response with a representation similar to an HTTP response that can
// be used within another message.
type Response2 struct {
	// A status code that should follow the HTTP status codes.
	Status int32 `protobuf:"varint,1,opt,name=status" json:"status,omitempty"`
	// A message associated with the response code.
	Message string `protobuf:"bytes,2,opt,name=message" json:"message,omitempty"`
	// A payload that can be used to include metadata with this response.
	Payload []byte `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *Response2) Reset()         { *m = Response2{} }
func (m *Response2) String() string { return proto.CompactTextString(m) }
func (*Response2) ProtoMessage()    {}

// A SystemChaincode is a chaincode compiled into the peer that cannot
// be modified at runtime. These are used to perform critical system level
// functions, including processing endorsements and validating transactions.
type SystemChaincode struct {
	// The ID used to identify a system chaincode.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
}

func (m *SystemChaincode) Reset()         { *m = SystemChaincode{} }
func (m *SystemChaincode) String() string { return proto.CompactTextString(m) }
func (*SystemChaincode) ProtoMessage()    {}

// An action to be taken against the ledger.
type Action struct {
	// Hash of proposal encoded in the Message2 payload. NDD.
	ProposalHash []byte `protobuf:"bytes,1,opt,name=proposalHash,proto3" json:"proposalHash,omitempty"`
	// Uncommitted state changes (simulated) as calculated by the endorser.
	// This generally would include MVCC and PostImage information for both the
	// read set and write set. This is to be forwarded to the ordering
	// service as part of the transaction and must match the simulationResult
	// returned by other endorsers for the proposal.
	SimulationResult []byte `protobuf:"bytes,2,opt,name=simulationResult,proto3" json:"simulationResult,omitempty"`
	// Events that should be sent by committers after the transaction is written
	// to the ledger. This is to be forwarded to the ordering
	// service as part of the transaction and must match the events
	// returned by other endorsers for the proposal.
	Events [][]byte `protobuf:"bytes,3,rep,name=events,proto3" json:"events,omitempty"`
	// ESCC (Endorser System Chaincode) is logic that is run prior to the
	// ProposalResponse being returned to the SDK. It can manipulate the
	// ProposalResponse as needed.
	Escc *SystemChaincode `protobuf:"bytes,4,opt,name=escc" json:"escc,omitempty"`
	// VSCC (Validaing System Chaincode) is logic that is run to transform the
	// raw ledger into the validated ledger.
	Vscc *SystemChaincode `protobuf:"bytes,5,opt,name=vscc" json:"vscc,omitempty"`
}

func (m *Action) Reset()         { *m = Action{} }
func (m *Action) String() string { return proto.CompactTextString(m) }
func (*Action) ProtoMessage()    {}

func (m *Action) GetEscc() *SystemChaincode {
	if m != nil {
		return m.Escc
	}
	return nil
}

func (m *Action) GetVscc() *SystemChaincode {
	if m != nil {
		return m.Vscc
	}
	return nil
}

// Endorsement is included within a proposal response.
type Endorsement struct {
	// Signature of the actionBytes included in the Endorsement.
	Signature []byte `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *Endorsement) Reset()         { *m = Endorsement{} }
func (m *Endorsement) String() string { return proto.CompactTextString(m) }
func (*Endorsement) ProtoMessage()    {}

// A ProposalResponse is returned from an endorser to the proposal submitter.
type ProposalResponse struct {
	// A response message indicating whether the endorsement of the action
	// was successful. Additional metadata can be included. This will not
	// be forwarded from the SDK to the ordering service.
	Response *Response2 `protobuf:"bytes,1,opt,name=response" json:"response,omitempty"`
	// A serialized Action message. NDD.
	ActionBytes []byte `protobuf:"bytes,2,opt,name=actionBytes,proto3" json:"actionBytes,omitempty"`
	// The endorsement of the action included in the proposal response
	Endorsement *Endorsement `protobuf:"bytes,3,opt,name=endorsement" json:"endorsement,omitempty"`
}

func (m *ProposalResponse) Reset()         { *m = ProposalResponse{} }
func (m *ProposalResponse) String() string { return proto.CompactTextString(m) }
func (*ProposalResponse) ProtoMessage()    {}

func (m *ProposalResponse) GetResponse() *Response2 {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *ProposalResponse) GetEndorsement() *Endorsement {
	if m != nil {
		return m.Endorsement
	}
	return nil
}

// An EndorsedAction describes a single action endorsed by one or more
// endorsers. Multiple endorsed actions can be included in a single
// transaction. The transaction is atomic meaning that either all
// actions in the transaction will be committed or none will be committed.
type EndorsedAction struct {
	// The action to be taken against the ledger. This is generally constructed
	// by an endorser. NDD.
	ActionBytes []byte `protobuf:"bytes,1,opt,name=actionBytes,proto3" json:"actionBytes,omitempty"`
	// The endorsements of the action.
	Endorsements []*Endorsement `protobuf:"bytes,2,rep,name=endorsements" json:"endorsements,omitempty"`
	// The proposal. This is optional and only needed if the SDK wants to store
	// the Proposal on the ledger as opposed to just the hash. The proposal is
	// not included within the Action because it is the SDK's decision whether
	// or not they would like to include this information in the Transaction2.
	// If it was in the Action and signed, either the Endorsers would be
	// required to make the decision or the SDK would need to provide a hint
	// in the Proposal about whether it should be included in the Action.
	// TODO Revisit this decision.
	ProposalBytes []byte `protobuf:"bytes,3,opt,name=proposalBytes,proto3" json:"proposalBytes,omitempty"`
}

func (m *EndorsedAction) Reset()         { *m = EndorsedAction{} }
func (m *EndorsedAction) String() string { return proto.CompactTextString(m) }
func (*EndorsedAction) ProtoMessage()    {}

func (m *EndorsedAction) GetEndorsements() []*Endorsement {
	if m != nil {
		return m.Endorsements
	}
	return nil
}

// The transaction to be sent to the ordering service. A transaction contains
// one or more endorsed actions. The transaction is atomic meaning that either
// all actions in the transaction will be committed or none will be committed.
type Transaction2 struct {
	// One or more endorsed actions to be committed to the ledger.
	EndorsedActions []*EndorsedAction `protobuf:"bytes,1,rep,name=endorsedActions" json:"endorsedActions,omitempty"`
}

func (m *Transaction2) Reset()         { *m = Transaction2{} }
func (m *Transaction2) String() string { return proto.CompactTextString(m) }
func (*Transaction2) ProtoMessage()    {}

func (m *Transaction2) GetEndorsedActions() []*EndorsedAction {
	if m != nil {
		return m.EndorsedActions
	}
	return nil
}

func init() {
	proto.RegisterEnum("protos.Message2_Type", Message2_Type_name, Message2_Type_value)
	proto.RegisterEnum("protos.Proposal_Type", Proposal_Type_name, Proposal_Type_value)
}
