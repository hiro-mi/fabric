// Code generated by protoc-gen-go. DO NOT EDIT.
// source: ledger/rwset/kvrwset/kv_rwset.proto

/*
Package kvrwset is a generated protocol buffer package.

It is generated from these files:
	ledger/rwset/kvrwset/kv_rwset.proto

It has these top-level messages:
	KVRWSet
	HashedRWSet
	KVRead
	KVWrite
	KVReadHash
	KVWriteHash
	KVMetadataWrite
	KVMetadataEntry
	Version
	RangeQueryInfo
	QueryReads
	QueryReadsMerkleSummary
*/
package kvrwset

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// KVRWSet encapsulates the read-write set for a chaincode that operates upon a KV or Document data model
// This structure is used for both the public data and the private data
type KVRWSet struct {
	Reads            []*KVRead         `protobuf:"bytes,1,rep,name=reads" json:"reads,omitempty"`
	RangeQueriesInfo []*RangeQueryInfo `protobuf:"bytes,2,rep,name=range_queries_info,json=rangeQueriesInfo" json:"range_queries_info,omitempty"`
	Writes           []*KVWrite        `protobuf:"bytes,3,rep,name=writes" json:"writes,omitempty"`
}

func (m *KVRWSet) Reset()                    { *m = KVRWSet{} }
func (m *KVRWSet) String() string            { return proto.CompactTextString(m) }
func (*KVRWSet) ProtoMessage()               {}
func (*KVRWSet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *KVRWSet) GetReads() []*KVRead {
	if m != nil {
		return m.Reads
	}
	return nil
}

func (m *KVRWSet) GetRangeQueriesInfo() []*RangeQueryInfo {
	if m != nil {
		return m.RangeQueriesInfo
	}
	return nil
}

func (m *KVRWSet) GetWrites() []*KVWrite {
	if m != nil {
		return m.Writes
	}
	return nil
}

// HashedRWSet encapsulates hashed representation of a private read-write set for KV or Document data model
type HashedRWSet struct {
	HashedReads  []*KVReadHash  `protobuf:"bytes,1,rep,name=hashed_reads,json=hashedReads" json:"hashed_reads,omitempty"`
	HashedWrites []*KVWriteHash `protobuf:"bytes,2,rep,name=hashed_writes,json=hashedWrites" json:"hashed_writes,omitempty"`
}

func (m *HashedRWSet) Reset()                    { *m = HashedRWSet{} }
func (m *HashedRWSet) String() string            { return proto.CompactTextString(m) }
func (*HashedRWSet) ProtoMessage()               {}
func (*HashedRWSet) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *HashedRWSet) GetHashedReads() []*KVReadHash {
	if m != nil {
		return m.HashedReads
	}
	return nil
}

func (m *HashedRWSet) GetHashedWrites() []*KVWriteHash {
	if m != nil {
		return m.HashedWrites
	}
	return nil
}

// KVRead captures a read operation performed during transaction simulation
// A 'nil' version indicates a non-existing key read by the transaction
type KVRead struct {
	Key     string   `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	Version *Version `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
}

func (m *KVRead) Reset()                    { *m = KVRead{} }
func (m *KVRead) String() string            { return proto.CompactTextString(m) }
func (*KVRead) ProtoMessage()               {}
func (*KVRead) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *KVRead) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KVRead) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

// KVWrite captures a write (update/delete) operation performed during transaction simulation
// Four operations are supported:
// 1) value update: if KeepExistingValue is false, the value is updated to Value
// 2) metadata update: if Metadata is not nil, all entries in Metadata.Upserts are applied
// 3) medatadata deletion: if Metadata is nil, all metadata is deleted
// 4) deletion: if IsDelete is set, this key is removed from the ledger.
// Note that 1 and 2 (or 3) may be combined.
type KVWrite struct {
	Key      string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	IsDelete bool   `protobuf:"varint,2,opt,name=is_delete,json=isDelete" json:"is_delete,omitempty"`
	Value    []byte `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
	// The two values below have been added in v1.2. Note that their default values
	// describe a behaviour which is consistent with that of of pre-1.2 code:
	// - if KeepExistingValue is false, the value is updated to value (unless IsDelete is true).
	// - if Metadata is nil, metadata is deleted for this key.
	KeepExistingValue bool             `protobuf:"varint,4,opt,name=keep_existing_value,json=keepExistingValue" json:"keep_existing_value,omitempty"`
	Metadata          *KVMetadataWrite `protobuf:"bytes,5,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *KVWrite) Reset()                    { *m = KVWrite{} }
func (m *KVWrite) String() string            { return proto.CompactTextString(m) }
func (*KVWrite) ProtoMessage()               {}
func (*KVWrite) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *KVWrite) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *KVWrite) GetIsDelete() bool {
	if m != nil {
		return m.IsDelete
	}
	return false
}

func (m *KVWrite) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *KVWrite) GetKeepExistingValue() bool {
	if m != nil {
		return m.KeepExistingValue
	}
	return false
}

func (m *KVWrite) GetMetadata() *KVMetadataWrite {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// KVReadHash is similar to the KVRead in spirit. However, it captures the hash of the key instead of the key itself
// version is kept as is for now. However, if the version also needs to be privacy-protected, it would need to be the
// hash of the version and hence of 'bytes' type
type KVReadHash struct {
	KeyHash []byte   `protobuf:"bytes,1,opt,name=key_hash,json=keyHash,proto3" json:"key_hash,omitempty"`
	Version *Version `protobuf:"bytes,2,opt,name=version" json:"version,omitempty"`
}

func (m *KVReadHash) Reset()                    { *m = KVReadHash{} }
func (m *KVReadHash) String() string            { return proto.CompactTextString(m) }
func (*KVReadHash) ProtoMessage()               {}
func (*KVReadHash) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *KVReadHash) GetKeyHash() []byte {
	if m != nil {
		return m.KeyHash
	}
	return nil
}

func (m *KVReadHash) GetVersion() *Version {
	if m != nil {
		return m.Version
	}
	return nil
}

// KVWriteHash is similar to the KVWrite. It captures a write (update/delete) operation performed during transaction simulation
// for a hashed key and to a hashed value. Note that metadata are stored in cleartext (no hash).
// Similar considerations to KVWrite apply here.
type KVWriteHash struct {
	KeyHash           []byte           `protobuf:"bytes,1,opt,name=key_hash,json=keyHash,proto3" json:"key_hash,omitempty"`
	IsDelete          bool             `protobuf:"varint,2,opt,name=is_delete,json=isDelete" json:"is_delete,omitempty"`
	ValueHash         []byte           `protobuf:"bytes,3,opt,name=value_hash,json=valueHash,proto3" json:"value_hash,omitempty"`
	KeepExistingValue bool             `protobuf:"varint,4,opt,name=keep_existing_value,json=keepExistingValue" json:"keep_existing_value,omitempty"`
	Metadata          *KVMetadataWrite `protobuf:"bytes,5,opt,name=metadata" json:"metadata,omitempty"`
}

func (m *KVWriteHash) Reset()                    { *m = KVWriteHash{} }
func (m *KVWriteHash) String() string            { return proto.CompactTextString(m) }
func (*KVWriteHash) ProtoMessage()               {}
func (*KVWriteHash) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *KVWriteHash) GetKeyHash() []byte {
	if m != nil {
		return m.KeyHash
	}
	return nil
}

func (m *KVWriteHash) GetIsDelete() bool {
	if m != nil {
		return m.IsDelete
	}
	return false
}

func (m *KVWriteHash) GetValueHash() []byte {
	if m != nil {
		return m.ValueHash
	}
	return nil
}

func (m *KVWriteHash) GetKeepExistingValue() bool {
	if m != nil {
		return m.KeepExistingValue
	}
	return false
}

func (m *KVWriteHash) GetMetadata() *KVMetadataWrite {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// KVMetadata captures all the upserts to the metadata associated with a key
type KVMetadataWrite struct {
	Upserts []*KVMetadataEntry `protobuf:"bytes,1,rep,name=upserts" json:"upserts,omitempty"`
	Deletes []string           `protobuf:"bytes,2,rep,name=deletes" json:"deletes,omitempty"`
}

func (m *KVMetadataWrite) Reset()                    { *m = KVMetadataWrite{} }
func (m *KVMetadataWrite) String() string            { return proto.CompactTextString(m) }
func (*KVMetadataWrite) ProtoMessage()               {}
func (*KVMetadataWrite) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *KVMetadataWrite) GetUpserts() []*KVMetadataEntry {
	if m != nil {
		return m.Upserts
	}
	return nil
}

func (m *KVMetadataWrite) GetDeletes() []string {
	if m != nil {
		return m.Deletes
	}
	return nil
}

// KVMetadataEntry captures a 'name'ed entry in the metadata of a key.
type KVMetadataEntry struct {
	Name  string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *KVMetadataEntry) Reset()                    { *m = KVMetadataEntry{} }
func (m *KVMetadataEntry) String() string            { return proto.CompactTextString(m) }
func (*KVMetadataEntry) ProtoMessage()               {}
func (*KVMetadataEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *KVMetadataEntry) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *KVMetadataEntry) GetValue() []byte {
	if m != nil {
		return m.Value
	}
	return nil
}

// Version encapsulates the version of a Key
// A version of a committed key is maintained as the height of the transaction that committed the key.
// The height is represenetd as a tuple <blockNum, txNum> where the txNum is the position of the transaction
// (starting with 0) within block
type Version struct {
	BlockNum uint64 `protobuf:"varint,1,opt,name=block_num,json=blockNum" json:"block_num,omitempty"`
	TxNum    uint64 `protobuf:"varint,2,opt,name=tx_num,json=txNum" json:"tx_num,omitempty"`
}

func (m *Version) Reset()                    { *m = Version{} }
func (m *Version) String() string            { return proto.CompactTextString(m) }
func (*Version) ProtoMessage()               {}
func (*Version) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Version) GetBlockNum() uint64 {
	if m != nil {
		return m.BlockNum
	}
	return 0
}

func (m *Version) GetTxNum() uint64 {
	if m != nil {
		return m.TxNum
	}
	return 0
}

// RangeQueryInfo encapsulates the details of a range query performed by a transaction during simulation.
// This helps protect transactions from phantom reads by varifying during validation whether any new items
// got committed within the given range between transaction simuation and validation
// (in addition to regular checks for updates/deletes of the existing items).
// readInfo field contains either the KVReads (for the items read by the range query) or a merkle-tree hash
// if the KVReads exceeds a pre-configured numbers
type RangeQueryInfo struct {
	StartKey     string `protobuf:"bytes,1,opt,name=start_key,json=startKey" json:"start_key,omitempty"`
	EndKey       string `protobuf:"bytes,2,opt,name=end_key,json=endKey" json:"end_key,omitempty"`
	ItrExhausted bool   `protobuf:"varint,3,opt,name=itr_exhausted,json=itrExhausted" json:"itr_exhausted,omitempty"`
	// Types that are valid to be assigned to ReadsInfo:
	//	*RangeQueryInfo_RawReads
	//	*RangeQueryInfo_ReadsMerkleHashes
	ReadsInfo isRangeQueryInfo_ReadsInfo `protobuf_oneof:"reads_info"`
}

func (m *RangeQueryInfo) Reset()                    { *m = RangeQueryInfo{} }
func (m *RangeQueryInfo) String() string            { return proto.CompactTextString(m) }
func (*RangeQueryInfo) ProtoMessage()               {}
func (*RangeQueryInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type isRangeQueryInfo_ReadsInfo interface{ isRangeQueryInfo_ReadsInfo() }

type RangeQueryInfo_RawReads struct {
	RawReads *QueryReads `protobuf:"bytes,4,opt,name=raw_reads,json=rawReads,oneof"`
}
type RangeQueryInfo_ReadsMerkleHashes struct {
	ReadsMerkleHashes *QueryReadsMerkleSummary `protobuf:"bytes,5,opt,name=reads_merkle_hashes,json=readsMerkleHashes,oneof"`
}

func (*RangeQueryInfo_RawReads) isRangeQueryInfo_ReadsInfo()          {}
func (*RangeQueryInfo_ReadsMerkleHashes) isRangeQueryInfo_ReadsInfo() {}

func (m *RangeQueryInfo) GetReadsInfo() isRangeQueryInfo_ReadsInfo {
	if m != nil {
		return m.ReadsInfo
	}
	return nil
}

func (m *RangeQueryInfo) GetStartKey() string {
	if m != nil {
		return m.StartKey
	}
	return ""
}

func (m *RangeQueryInfo) GetEndKey() string {
	if m != nil {
		return m.EndKey
	}
	return ""
}

func (m *RangeQueryInfo) GetItrExhausted() bool {
	if m != nil {
		return m.ItrExhausted
	}
	return false
}

func (m *RangeQueryInfo) GetRawReads() *QueryReads {
	if x, ok := m.GetReadsInfo().(*RangeQueryInfo_RawReads); ok {
		return x.RawReads
	}
	return nil
}

func (m *RangeQueryInfo) GetReadsMerkleHashes() *QueryReadsMerkleSummary {
	if x, ok := m.GetReadsInfo().(*RangeQueryInfo_ReadsMerkleHashes); ok {
		return x.ReadsMerkleHashes
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*RangeQueryInfo) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _RangeQueryInfo_OneofMarshaler, _RangeQueryInfo_OneofUnmarshaler, _RangeQueryInfo_OneofSizer, []interface{}{
		(*RangeQueryInfo_RawReads)(nil),
		(*RangeQueryInfo_ReadsMerkleHashes)(nil),
	}
}

func _RangeQueryInfo_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*RangeQueryInfo)
	// reads_info
	switch x := m.ReadsInfo.(type) {
	case *RangeQueryInfo_RawReads:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RawReads); err != nil {
			return err
		}
	case *RangeQueryInfo_ReadsMerkleHashes:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ReadsMerkleHashes); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("RangeQueryInfo.ReadsInfo has unexpected type %T", x)
	}
	return nil
}

func _RangeQueryInfo_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*RangeQueryInfo)
	switch tag {
	case 4: // reads_info.raw_reads
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(QueryReads)
		err := b.DecodeMessage(msg)
		m.ReadsInfo = &RangeQueryInfo_RawReads{msg}
		return true, err
	case 5: // reads_info.reads_merkle_hashes
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(QueryReadsMerkleSummary)
		err := b.DecodeMessage(msg)
		m.ReadsInfo = &RangeQueryInfo_ReadsMerkleHashes{msg}
		return true, err
	default:
		return false, nil
	}
}

func _RangeQueryInfo_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*RangeQueryInfo)
	// reads_info
	switch x := m.ReadsInfo.(type) {
	case *RangeQueryInfo_RawReads:
		s := proto.Size(x.RawReads)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *RangeQueryInfo_ReadsMerkleHashes:
		s := proto.Size(x.ReadsMerkleHashes)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// QueryReads encapsulates the KVReads for the items read by a transaction as a result of a query execution
type QueryReads struct {
	KvReads []*KVRead `protobuf:"bytes,1,rep,name=kv_reads,json=kvReads" json:"kv_reads,omitempty"`
}

func (m *QueryReads) Reset()                    { *m = QueryReads{} }
func (m *QueryReads) String() string            { return proto.CompactTextString(m) }
func (*QueryReads) ProtoMessage()               {}
func (*QueryReads) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *QueryReads) GetKvReads() []*KVRead {
	if m != nil {
		return m.KvReads
	}
	return nil
}

// QueryReadsMerkleSummary encapsulates the Merkle-tree hashes for the QueryReads
// This allows to reduce the size of RWSet in the presence of query results
// by storing certain hashes instead of actual results.
// maxDegree field refers to the maximum number of children in the tree at any level
// maxLevel field contains the lowest level which has lesser nodes than maxDegree (starting from leaf level)
type QueryReadsMerkleSummary struct {
	MaxDegree      uint32   `protobuf:"varint,1,opt,name=max_degree,json=maxDegree" json:"max_degree,omitempty"`
	MaxLevel       uint32   `protobuf:"varint,2,opt,name=max_level,json=maxLevel" json:"max_level,omitempty"`
	MaxLevelHashes [][]byte `protobuf:"bytes,3,rep,name=max_level_hashes,json=maxLevelHashes,proto3" json:"max_level_hashes,omitempty"`
}

func (m *QueryReadsMerkleSummary) Reset()                    { *m = QueryReadsMerkleSummary{} }
func (m *QueryReadsMerkleSummary) String() string            { return proto.CompactTextString(m) }
func (*QueryReadsMerkleSummary) ProtoMessage()               {}
func (*QueryReadsMerkleSummary) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *QueryReadsMerkleSummary) GetMaxDegree() uint32 {
	if m != nil {
		return m.MaxDegree
	}
	return 0
}

func (m *QueryReadsMerkleSummary) GetMaxLevel() uint32 {
	if m != nil {
		return m.MaxLevel
	}
	return 0
}

func (m *QueryReadsMerkleSummary) GetMaxLevelHashes() [][]byte {
	if m != nil {
		return m.MaxLevelHashes
	}
	return nil
}

func init() {
	proto.RegisterType((*KVRWSet)(nil), "kvrwset.KVRWSet")
	proto.RegisterType((*HashedRWSet)(nil), "kvrwset.HashedRWSet")
	proto.RegisterType((*KVRead)(nil), "kvrwset.KVRead")
	proto.RegisterType((*KVWrite)(nil), "kvrwset.KVWrite")
	proto.RegisterType((*KVReadHash)(nil), "kvrwset.KVReadHash")
	proto.RegisterType((*KVWriteHash)(nil), "kvrwset.KVWriteHash")
	proto.RegisterType((*KVMetadataWrite)(nil), "kvrwset.KVMetadataWrite")
	proto.RegisterType((*KVMetadataEntry)(nil), "kvrwset.KVMetadataEntry")
	proto.RegisterType((*Version)(nil), "kvrwset.Version")
	proto.RegisterType((*RangeQueryInfo)(nil), "kvrwset.RangeQueryInfo")
	proto.RegisterType((*QueryReads)(nil), "kvrwset.QueryReads")
	proto.RegisterType((*QueryReadsMerkleSummary)(nil), "kvrwset.QueryReadsMerkleSummary")
}

func init() { proto.RegisterFile("ledger/rwset/kvrwset/kv_rwset.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 754 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xbc, 0x55, 0xdd, 0x6a, 0xe3, 0x46,
	0x14, 0x5e, 0x39, 0xb1, 0x25, 0x1f, 0xdb, 0xbb, 0xde, 0xc9, 0x96, 0xa8, 0x94, 0x82, 0xd1, 0x52,
	0x30, 0x7b, 0x21, 0x83, 0x5b, 0x4a, 0x97, 0xd2, 0x9b, 0xb2, 0x2e, 0x29, 0xe9, 0x2e, 0x74, 0x02,
	0x0e, 0xf4, 0x46, 0x8c, 0xa3, 0x13, 0x5b, 0xc8, 0x92, 0xdc, 0x99, 0x91, 0x6d, 0x5d, 0xb5, 0x7d,
	0x94, 0xbe, 0x43, 0x9f, 0xa2, 0x4f, 0x55, 0xe6, 0x8c, 0x14, 0x7b, 0x83, 0x1b, 0xe8, 0x4d, 0xaf,
	0xa4, 0x39, 0xdf, 0xf9, 0xce, 0xcf, 0x37, 0x67, 0x66, 0xe0, 0xf5, 0x1a, 0xe3, 0x25, 0xca, 0x89,
	0xdc, 0x29, 0xd4, 0x93, 0x74, 0xdb, 0x7c, 0x23, 0xfa, 0x09, 0x37, 0xb2, 0xd0, 0x05, 0x73, 0x6b,
	0x7b, 0xf0, 0xa7, 0x03, 0xee, 0xf5, 0x9c, 0xdf, 0xde, 0xa0, 0x66, 0x5f, 0x40, 0x5b, 0xa2, 0x88,
	0x95, 0xef, 0x8c, 0xce, 0xc6, 0xbd, 0xe9, 0x8b, 0xb0, 0x76, 0x0a, 0xaf, 0xe7, 0x1c, 0x45, 0xcc,
	0x2d, 0xca, 0x66, 0xc0, 0xa4, 0xc8, 0x97, 0x18, 0xfd, 0x5a, 0xa2, 0x4c, 0x50, 0x45, 0x49, 0x7e,
	0x5f, 0xf8, 0x2d, 0xe2, 0x5c, 0x3e, 0x70, 0xb8, 0x71, 0xf9, 0xb9, 0x44, 0x59, 0xfd, 0x98, 0xdf,
	0x17, 0x7c, 0x28, 0x9b, 0x75, 0x82, 0xca, 0x58, 0xd8, 0x18, 0x3a, 0x3b, 0x99, 0x68, 0x54, 0xfe,
	0x19, 0x51, 0x87, 0x47, 0xe9, 0x6e, 0x0d, 0xc0, 0x6b, 0x3c, 0xf8, 0xdd, 0x81, 0xde, 0x95, 0x50,
	0x2b, 0x8c, 0x6d, 0x9d, 0x5f, 0x43, 0x7f, 0x45, 0xcb, 0xe8, 0xb8, 0xdc, 0x8b, 0x47, 0xe5, 0x1a,
	0x06, 0xef, 0x59, 0x47, 0x4e, 0x85, 0xbf, 0x85, 0x41, 0xcd, 0xab, 0x13, 0xdb, 0x9a, 0x5f, 0x3d,
	0x4e, 0x4c, 0xcc, 0x3a, 0xc5, 0xad, 0x2d, 0xe1, 0x07, 0xe8, 0xd8, 0xa8, 0x6c, 0x08, 0x67, 0x29,
	0x56, 0xbe, 0x33, 0x72, 0xc6, 0x5d, 0x6e, 0x7e, 0xd9, 0x1b, 0x70, 0xb7, 0x28, 0x55, 0x52, 0xe4,
	0x7e, 0x6b, 0xe4, 0x7c, 0xd4, 0xc9, 0xdc, 0xda, 0x79, 0xe3, 0x10, 0xfc, 0x45, 0x72, 0x53, 0xd0,
	0x13, 0x91, 0x3e, 0x83, 0x6e, 0xa2, 0xa2, 0x18, 0xd7, 0xa8, 0x91, 0x62, 0x79, 0xdc, 0x4b, 0xd4,
	0x3b, 0x5a, 0xb3, 0x57, 0xd0, 0xde, 0x8a, 0x75, 0x89, 0xfe, 0xd9, 0xc8, 0x19, 0xf7, 0xb9, 0x5d,
	0xb0, 0x10, 0x2e, 0x52, 0xc4, 0x4d, 0x84, 0xfb, 0x44, 0xe9, 0x24, 0x5f, 0x46, 0xd6, 0xe7, 0x9c,
	0xc8, 0x2f, 0x0d, 0x34, 0xab, 0x91, 0x39, 0xf9, 0x7f, 0x05, 0x5e, 0x86, 0x5a, 0xc4, 0x42, 0x0b,
	0xbf, 0x4d, 0xd5, 0xfa, 0x47, 0xed, 0xbf, 0xaf, 0x21, 0xab, 0xff, 0x83, 0x67, 0x70, 0x03, 0x70,
	0x10, 0x95, 0x7d, 0x0a, 0x5e, 0x8a, 0x55, 0x64, 0x04, 0xa2, 0xea, 0xfb, 0xdc, 0x4d, 0xb1, 0x22,
	0xe8, 0xbf, 0x68, 0xf1, 0xb7, 0x03, 0xbd, 0x23, 0xc5, 0x9f, 0x0a, 0xfb, 0xa4, 0x30, 0x9f, 0x03,
	0x50, 0xd3, 0x96, 0x69, 0xd5, 0xe9, 0x92, 0x85, 0xb8, 0xff, 0x8f, 0x42, 0x11, 0xbc, 0x78, 0x04,
	0xb2, 0x29, 0xb8, 0xe5, 0x46, 0xa1, 0xd4, 0xcd, 0x84, 0x9e, 0x8a, 0x33, 0xcb, 0xb5, 0xac, 0x78,
	0xe3, 0xc8, 0x7c, 0x70, 0x6d, 0x97, 0x76, 0x38, 0xbb, 0xbc, 0x59, 0x06, 0xdf, 0x1e, 0x27, 0x20,
	0x16, 0x63, 0x70, 0x9e, 0x8b, 0x0c, 0xeb, 0x09, 0xa2, 0xff, 0xc3, 0x94, 0xb4, 0x8e, 0xa6, 0x24,
	0xf8, 0x0e, 0xdc, 0x5a, 0x7e, 0x23, 0xe5, 0x62, 0x5d, 0xdc, 0xa5, 0x51, 0x5e, 0x66, 0xc4, 0x3c,
	0xe7, 0x1e, 0x19, 0x3e, 0x94, 0x19, 0xfb, 0x04, 0x3a, 0x7a, 0x4f, 0x48, 0x8b, 0x90, 0xb6, 0xde,
	0x7f, 0x28, 0xb3, 0xe0, 0x8f, 0x16, 0x3c, 0xff, 0xf8, 0x3c, 0x9b, 0x30, 0x4a, 0x0b, 0xa9, 0xa3,
	0xc3, 0x08, 0x7b, 0x64, 0xb8, 0xc6, 0x8a, 0x5d, 0x82, 0x8b, 0x79, 0x4c, 0x50, 0x8b, 0xa0, 0x0e,
	0xe6, 0xb1, 0x01, 0x5e, 0xc3, 0x20, 0xd1, 0x32, 0xc2, 0xfd, 0x4a, 0x94, 0x4a, 0x63, 0x4c, 0xbb,
	0xe5, 0xf1, 0x7e, 0xa2, 0xe5, 0xac, 0xb1, 0xb1, 0x29, 0x74, 0xa5, 0xd8, 0xd5, 0x67, 0xfb, 0x9c,
	0x76, 0xe0, 0x70, 0xb6, 0xa9, 0x02, 0x3a, 0xce, 0x57, 0xcf, 0xb8, 0x27, 0xc5, 0xce, 0x1e, 0x6d,
	0x0e, 0x17, 0xe4, 0x1f, 0x65, 0x28, 0xd3, 0xb5, 0x1d, 0x05, 0x54, 0xf5, 0xfe, 0x8d, 0x4e, 0xb0,
	0xdf, 0x93, 0xdf, 0x4d, 0x99, 0x65, 0x42, 0x56, 0x57, 0xcf, 0xf8, 0x4b, 0x79, 0xb0, 0xd2, 0x5d,
	0xa3, 0xbe, 0xef, 0x03, 0xd8, 0x98, 0xe6, 0x7e, 0x0b, 0xbe, 0x01, 0x38, 0xb0, 0xd9, 0x1b, 0xf0,
	0xcc, 0x8d, 0xfa, 0xd4, 0x6d, 0xe9, 0xa6, 0x5b, 0xf2, 0x0d, 0x7e, 0x83, 0xcb, 0x7f, 0xc9, 0x6b,
	0x46, 0x37, 0x13, 0xfb, 0x28, 0xc6, 0xa5, 0x44, 0xbb, 0x8f, 0x03, 0xde, 0xcd, 0xc4, 0xfe, 0x1d,
	0x19, 0x8c, 0xc8, 0x06, 0x5e, 0xe3, 0x16, 0xd7, 0xa4, 0xe4, 0x80, 0x7b, 0x99, 0xd8, 0xff, 0x64,
	0xd6, 0x6c, 0x0c, 0xc3, 0x07, 0xb0, 0xe9, 0xd7, 0xdc, 0xa4, 0x7d, 0xfe, 0xbc, 0xf1, 0xa9, 0x1b,
	0x29, 0x60, 0x5a, 0xc8, 0x65, 0xb8, 0xaa, 0x36, 0x28, 0xed, 0xe3, 0x10, 0xde, 0x8b, 0x85, 0x4c,
	0xee, 0xec, 0x63, 0xa0, 0xc2, 0xda, 0x68, 0xcb, 0xaf, 0xdb, 0xf8, 0xe5, 0xed, 0x32, 0xd1, 0xab,
	0x72, 0x11, 0xde, 0x15, 0xd9, 0xe4, 0x88, 0x3a, 0xb1, 0xd4, 0x89, 0xa5, 0x4e, 0x4e, 0x3d, 0x36,
	0x8b, 0x0e, 0x81, 0x5f, 0xfe, 0x13, 0x00, 0x00, 0xff, 0xff, 0x08, 0x42, 0x1a, 0xf5, 0x8b, 0x06,
	0x00, 0x00,
}
