// Code generated by protoc-gen-go.
// source: message.proto
// DO NOT EDIT!

/*
Package proto is a generated protocol buffer package.

It is generated from these files:
	message.proto

It has these top-level messages:
	GossipMessage
	DataRequest
	GossipHello
	DataUpdate
	DataDigest
	DataMessage
	AckMessage
	Payload
	AliveMessage
	PeerTime
	MembershipRequest
	MembershipResponse
	Member
	Empty
*/
package proto

import proto1 "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto1.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type GossipMessage struct {
	Nonce uint64 `protobuf:"varint,1,opt,name=nonce" json:"nonce,omitempty"`
	// Types that are valid to be assigned to Content:
	//	*GossipMessage_AliveMsg
	//	*GossipMessage_MemReq
	//	*GossipMessage_MemRes
	//	*GossipMessage_DataMsg
	//	*GossipMessage_Hello
	//	*GossipMessage_DataDig
	//	*GossipMessage_DataReq
	//	*GossipMessage_DataUpdate
	//	*GossipMessage_AckMsg
	//	*GossipMessage_Empty
	Content isGossipMessage_Content `protobuf_oneof:"content"`
}

func (m *GossipMessage) Reset()         { *m = GossipMessage{} }
func (m *GossipMessage) String() string { return proto1.CompactTextString(m) }
func (*GossipMessage) ProtoMessage()    {}

type isGossipMessage_Content interface {
	isGossipMessage_Content()
}

type GossipMessage_AliveMsg struct {
	AliveMsg *AliveMessage `protobuf:"bytes,2,opt,name=aliveMsg,oneof"`
}
type GossipMessage_MemReq struct {
	MemReq *MembershipRequest `protobuf:"bytes,3,opt,name=memReq,oneof"`
}
type GossipMessage_MemRes struct {
	MemRes *MembershipResponse `protobuf:"bytes,4,opt,name=memRes,oneof"`
}
type GossipMessage_DataMsg struct {
	DataMsg *DataMessage `protobuf:"bytes,5,opt,name=dataMsg,oneof"`
}
type GossipMessage_Hello struct {
	Hello *GossipHello `protobuf:"bytes,6,opt,name=hello,oneof"`
}
type GossipMessage_DataDig struct {
	DataDig *DataDigest `protobuf:"bytes,7,opt,name=dataDig,oneof"`
}
type GossipMessage_DataReq struct {
	DataReq *DataRequest `protobuf:"bytes,8,opt,name=dataReq,oneof"`
}
type GossipMessage_DataUpdate struct {
	DataUpdate *DataUpdate `protobuf:"bytes,9,opt,name=dataUpdate,oneof"`
}
type GossipMessage_AckMsg struct {
	AckMsg *AckMessage `protobuf:"bytes,10,opt,name=ackMsg,oneof"`
}
type GossipMessage_Empty struct {
	Empty *Empty `protobuf:"bytes,11,opt,name=empty,oneof"`
}

func (*GossipMessage_AliveMsg) isGossipMessage_Content()   {}
func (*GossipMessage_MemReq) isGossipMessage_Content()     {}
func (*GossipMessage_MemRes) isGossipMessage_Content()     {}
func (*GossipMessage_DataMsg) isGossipMessage_Content()    {}
func (*GossipMessage_Hello) isGossipMessage_Content()      {}
func (*GossipMessage_DataDig) isGossipMessage_Content()    {}
func (*GossipMessage_DataReq) isGossipMessage_Content()    {}
func (*GossipMessage_DataUpdate) isGossipMessage_Content() {}
func (*GossipMessage_AckMsg) isGossipMessage_Content()     {}
func (*GossipMessage_Empty) isGossipMessage_Content()      {}

func (m *GossipMessage) GetContent() isGossipMessage_Content {
	if m != nil {
		return m.Content
	}
	return nil
}

func (m *GossipMessage) GetAliveMsg() *AliveMessage {
	if x, ok := m.GetContent().(*GossipMessage_AliveMsg); ok {
		return x.AliveMsg
	}
	return nil
}

func (m *GossipMessage) GetMemReq() *MembershipRequest {
	if x, ok := m.GetContent().(*GossipMessage_MemReq); ok {
		return x.MemReq
	}
	return nil
}

func (m *GossipMessage) GetMemRes() *MembershipResponse {
	if x, ok := m.GetContent().(*GossipMessage_MemRes); ok {
		return x.MemRes
	}
	return nil
}

func (m *GossipMessage) GetDataMsg() *DataMessage {
	if x, ok := m.GetContent().(*GossipMessage_DataMsg); ok {
		return x.DataMsg
	}
	return nil
}

func (m *GossipMessage) GetHello() *GossipHello {
	if x, ok := m.GetContent().(*GossipMessage_Hello); ok {
		return x.Hello
	}
	return nil
}

func (m *GossipMessage) GetDataDig() *DataDigest {
	if x, ok := m.GetContent().(*GossipMessage_DataDig); ok {
		return x.DataDig
	}
	return nil
}

func (m *GossipMessage) GetDataReq() *DataRequest {
	if x, ok := m.GetContent().(*GossipMessage_DataReq); ok {
		return x.DataReq
	}
	return nil
}

func (m *GossipMessage) GetDataUpdate() *DataUpdate {
	if x, ok := m.GetContent().(*GossipMessage_DataUpdate); ok {
		return x.DataUpdate
	}
	return nil
}

func (m *GossipMessage) GetAckMsg() *AckMessage {
	if x, ok := m.GetContent().(*GossipMessage_AckMsg); ok {
		return x.AckMsg
	}
	return nil
}

func (m *GossipMessage) GetEmpty() *Empty {
	if x, ok := m.GetContent().(*GossipMessage_Empty); ok {
		return x.Empty
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*GossipMessage) XXX_OneofFuncs() (func(msg proto1.Message, b *proto1.Buffer) error, func(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error), []interface{}) {
	return _GossipMessage_OneofMarshaler, _GossipMessage_OneofUnmarshaler, []interface{}{
		(*GossipMessage_AliveMsg)(nil),
		(*GossipMessage_MemReq)(nil),
		(*GossipMessage_MemRes)(nil),
		(*GossipMessage_DataMsg)(nil),
		(*GossipMessage_Hello)(nil),
		(*GossipMessage_DataDig)(nil),
		(*GossipMessage_DataReq)(nil),
		(*GossipMessage_DataUpdate)(nil),
		(*GossipMessage_AckMsg)(nil),
		(*GossipMessage_Empty)(nil),
	}
}

func _GossipMessage_OneofMarshaler(msg proto1.Message, b *proto1.Buffer) error {
	m := msg.(*GossipMessage)
	// content
	switch x := m.Content.(type) {
	case *GossipMessage_AliveMsg:
		b.EncodeVarint(2<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.AliveMsg); err != nil {
			return err
		}
	case *GossipMessage_MemReq:
		b.EncodeVarint(3<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.MemReq); err != nil {
			return err
		}
	case *GossipMessage_MemRes:
		b.EncodeVarint(4<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.MemRes); err != nil {
			return err
		}
	case *GossipMessage_DataMsg:
		b.EncodeVarint(5<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.DataMsg); err != nil {
			return err
		}
	case *GossipMessage_Hello:
		b.EncodeVarint(6<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Hello); err != nil {
			return err
		}
	case *GossipMessage_DataDig:
		b.EncodeVarint(7<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.DataDig); err != nil {
			return err
		}
	case *GossipMessage_DataReq:
		b.EncodeVarint(8<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.DataReq); err != nil {
			return err
		}
	case *GossipMessage_DataUpdate:
		b.EncodeVarint(9<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.DataUpdate); err != nil {
			return err
		}
	case *GossipMessage_AckMsg:
		b.EncodeVarint(10<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.AckMsg); err != nil {
			return err
		}
	case *GossipMessage_Empty:
		b.EncodeVarint(11<<3 | proto1.WireBytes)
		if err := b.EncodeMessage(x.Empty); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("GossipMessage.Content has unexpected type %T", x)
	}
	return nil
}

func _GossipMessage_OneofUnmarshaler(msg proto1.Message, tag, wire int, b *proto1.Buffer) (bool, error) {
	m := msg.(*GossipMessage)
	switch tag {
	case 2: // content.aliveMsg
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(AliveMessage)
		err := b.DecodeMessage(msg)
		m.Content = &GossipMessage_AliveMsg{msg}
		return true, err
	case 3: // content.memReq
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(MembershipRequest)
		err := b.DecodeMessage(msg)
		m.Content = &GossipMessage_MemReq{msg}
		return true, err
	case 4: // content.memRes
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(MembershipResponse)
		err := b.DecodeMessage(msg)
		m.Content = &GossipMessage_MemRes{msg}
		return true, err
	case 5: // content.dataMsg
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(DataMessage)
		err := b.DecodeMessage(msg)
		m.Content = &GossipMessage_DataMsg{msg}
		return true, err
	case 6: // content.hello
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(GossipHello)
		err := b.DecodeMessage(msg)
		m.Content = &GossipMessage_Hello{msg}
		return true, err
	case 7: // content.dataDig
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(DataDigest)
		err := b.DecodeMessage(msg)
		m.Content = &GossipMessage_DataDig{msg}
		return true, err
	case 8: // content.dataReq
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(DataRequest)
		err := b.DecodeMessage(msg)
		m.Content = &GossipMessage_DataReq{msg}
		return true, err
	case 9: // content.dataUpdate
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(DataUpdate)
		err := b.DecodeMessage(msg)
		m.Content = &GossipMessage_DataUpdate{msg}
		return true, err
	case 10: // content.ackMsg
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(AckMessage)
		err := b.DecodeMessage(msg)
		m.Content = &GossipMessage_AckMsg{msg}
		return true, err
	case 11: // content.empty
		if wire != proto1.WireBytes {
			return true, proto1.ErrInternalBadWireType
		}
		msg := new(Empty)
		err := b.DecodeMessage(msg)
		m.Content = &GossipMessage_Empty{msg}
		return true, err
	default:
		return false, nil
	}
}

type DataRequest struct {
	Nonce  uint64   `protobuf:"varint,1,opt,name=nonce" json:"nonce,omitempty"`
	SeqMap []uint64 `protobuf:"varint,2,rep,name=seqMap" json:"seqMap,omitempty"`
}

func (m *DataRequest) Reset()         { *m = DataRequest{} }
func (m *DataRequest) String() string { return proto1.CompactTextString(m) }
func (*DataRequest) ProtoMessage()    {}

type GossipHello struct {
	Nonce uint64 `protobuf:"varint,1,opt,name=nonce" json:"nonce,omitempty"`
}

func (m *GossipHello) Reset()         { *m = GossipHello{} }
func (m *GossipHello) String() string { return proto1.CompactTextString(m) }
func (*GossipHello) ProtoMessage()    {}

type DataUpdate struct {
	Data []*DataMessage `protobuf:"bytes,1,rep,name=data" json:"data,omitempty"`
}

func (m *DataUpdate) Reset()         { *m = DataUpdate{} }
func (m *DataUpdate) String() string { return proto1.CompactTextString(m) }
func (*DataUpdate) ProtoMessage()    {}

func (m *DataUpdate) GetData() []*DataMessage {
	if m != nil {
		return m.Data
	}
	return nil
}

type DataDigest struct {
	Nonce  uint64   `protobuf:"varint,1,opt,name=nonce" json:"nonce,omitempty"`
	SeqMap []uint64 `protobuf:"varint,2,rep,name=seqMap" json:"seqMap,omitempty"`
}

func (m *DataDigest) Reset()         { *m = DataDigest{} }
func (m *DataDigest) String() string { return proto1.CompactTextString(m) }
func (*DataDigest) ProtoMessage()    {}

type DataMessage struct {
	Payload *Payload `protobuf:"bytes,1,opt,name=payload" json:"payload,omitempty"`
}

func (m *DataMessage) Reset()         { *m = DataMessage{} }
func (m *DataMessage) String() string { return proto1.CompactTextString(m) }
func (*DataMessage) ProtoMessage()    {}

func (m *DataMessage) GetPayload() *Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

type AckMessage struct {
	Nonce uint64 `protobuf:"varint,1,opt,name=nonce" json:"nonce,omitempty"`
}

func (m *AckMessage) Reset()         { *m = AckMessage{} }
func (m *AckMessage) String() string { return proto1.CompactTextString(m) }
func (*AckMessage) ProtoMessage()    {}

type Payload struct {
	SeqNum uint64 `protobuf:"varint,1,opt,name=seqNum" json:"seqNum,omitempty"`
	Hash   string `protobuf:"bytes,2,opt,name=hash" json:"hash,omitempty"`
	Data   []byte `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *Payload) Reset()         { *m = Payload{} }
func (m *Payload) String() string { return proto1.CompactTextString(m) }
func (*Payload) ProtoMessage()    {}

type AliveMessage struct {
	Membership *Member   `protobuf:"bytes,1,opt,name=membership" json:"membership,omitempty"`
	Timestamp  *PeerTime `protobuf:"bytes,2,opt,name=timestamp" json:"timestamp,omitempty"`
	Signature  []byte    `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *AliveMessage) Reset()         { *m = AliveMessage{} }
func (m *AliveMessage) String() string { return proto1.CompactTextString(m) }
func (*AliveMessage) ProtoMessage()    {}

func (m *AliveMessage) GetMembership() *Member {
	if m != nil {
		return m.Membership
	}
	return nil
}

func (m *AliveMessage) GetTimestamp() *PeerTime {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

type PeerTime struct {
	IncNumber uint64 `protobuf:"varint,1,opt,name=inc_number" json:"inc_number,omitempty"`
	SeqNum    uint64 `protobuf:"varint,2,opt,name=seqNum" json:"seqNum,omitempty"`
}

func (m *PeerTime) Reset()         { *m = PeerTime{} }
func (m *PeerTime) String() string { return proto1.CompactTextString(m) }
func (*PeerTime) ProtoMessage()    {}

type MembershipRequest struct {
	SelfInformation *AliveMessage `protobuf:"bytes,1,opt,name=selfInformation" json:"selfInformation,omitempty"`
	Known           []string      `protobuf:"bytes,2,rep,name=known" json:"known,omitempty"`
}

func (m *MembershipRequest) Reset()         { *m = MembershipRequest{} }
func (m *MembershipRequest) String() string { return proto1.CompactTextString(m) }
func (*MembershipRequest) ProtoMessage()    {}

func (m *MembershipRequest) GetSelfInformation() *AliveMessage {
	if m != nil {
		return m.SelfInformation
	}
	return nil
}

type MembershipResponse struct {
	Alive []*AliveMessage `protobuf:"bytes,1,rep,name=alive" json:"alive,omitempty"`
	Dead  []*AliveMessage `protobuf:"bytes,2,rep,name=dead" json:"dead,omitempty"`
}

func (m *MembershipResponse) Reset()         { *m = MembershipResponse{} }
func (m *MembershipResponse) String() string { return proto1.CompactTextString(m) }
func (*MembershipResponse) ProtoMessage()    {}

func (m *MembershipResponse) GetAlive() []*AliveMessage {
	if m != nil {
		return m.Alive
	}
	return nil
}

func (m *MembershipResponse) GetDead() []*AliveMessage {
	if m != nil {
		return m.Dead
	}
	return nil
}

type Member struct {
	Id       string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	Endpoint string `protobuf:"bytes,2,opt,name=endpoint" json:"endpoint,omitempty"`
	Metadata []byte `protobuf:"bytes,3,opt,name=metadata,proto3" json:"metadata,omitempty"`
}

func (m *Member) Reset()         { *m = Member{} }
func (m *Member) String() string { return proto1.CompactTextString(m) }
func (*Member) ProtoMessage()    {}

type Empty struct {
}

func (m *Empty) Reset()         { *m = Empty{} }
func (m *Empty) String() string { return proto1.CompactTextString(m) }
func (*Empty) ProtoMessage()    {}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// Client API for Gossip service

type GossipClient interface {
	GossipStream(ctx context.Context, opts ...grpc.CallOption) (Gossip_GossipStreamClient, error)
	Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error)
}

type gossipClient struct {
	cc *grpc.ClientConn
}

func NewGossipClient(cc *grpc.ClientConn) GossipClient {
	return &gossipClient{cc}
}

func (c *gossipClient) GossipStream(ctx context.Context, opts ...grpc.CallOption) (Gossip_GossipStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_Gossip_serviceDesc.Streams[0], c.cc, "/proto.Gossip/GossipStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &gossipGossipStreamClient{stream}
	return x, nil
}

type Gossip_GossipStreamClient interface {
	Send(*GossipMessage) error
	Recv() (*GossipMessage, error)
	grpc.ClientStream
}

type gossipGossipStreamClient struct {
	grpc.ClientStream
}

func (x *gossipGossipStreamClient) Send(m *GossipMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *gossipGossipStreamClient) Recv() (*GossipMessage, error) {
	m := new(GossipMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *gossipClient) Ping(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*Empty, error) {
	out := new(Empty)
	err := grpc.Invoke(ctx, "/proto.Gossip/Ping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Gossip service

type GossipServer interface {
	GossipStream(Gossip_GossipStreamServer) error
	Ping(context.Context, *Empty) (*Empty, error)
}

func RegisterGossipServer(s *grpc.Server, srv GossipServer) {
	s.RegisterService(&_Gossip_serviceDesc, srv)
}

func _Gossip_GossipStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(GossipServer).GossipStream(&gossipGossipStreamServer{stream})
}

type Gossip_GossipStreamServer interface {
	Send(*GossipMessage) error
	Recv() (*GossipMessage, error)
	grpc.ServerStream
}

type gossipGossipStreamServer struct {
	grpc.ServerStream
}

func (x *gossipGossipStreamServer) Send(m *GossipMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *gossipGossipStreamServer) Recv() (*GossipMessage, error) {
	m := new(GossipMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Gossip_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	out, err := srv.(GossipServer).Ping(ctx, in)
	if err != nil {
		return nil, err
	}
	return out, nil
}

var _Gossip_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.Gossip",
	HandlerType: (*GossipServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Ping",
			Handler:    _Gossip_Ping_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GossipStream",
			Handler:       _Gossip_GossipStream_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
}
